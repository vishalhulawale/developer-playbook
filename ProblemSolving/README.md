


## Guiding Principles (Read Once)
- Prioritize **clarity, correctness, and predictability**
- Avoid exotic data structures and competitive-programming tricks
- Always explain **why** a data structure or approach is chosen
- Be fluent with **time & space complexity** and **edge cases**
- Write **clean, defensive Java-style code**

---

## DAY 1 – Arrays & Strings (Foundation Day)

### Concepts to Master
- Time vs space trade-offs
- In-place algorithms
- Two pointers (same & opposite direction)
- Sliding window (fixed & variable)
- Prefix sum
- Kadane’s algorithm
- Edge cases (empty array, single element, all negatives)

### Core Problems (Must Do)
1. Maximum Subarray Sum (Kadane’s Algorithm)
2. Subarray Sum Equals K (Prefix Sum + HashMap)
3. Longest Substring Without Repeating Characters
4. Rotate Array (In-place using reverse)
5. Merge Intervals
6. Majority Element (HashMap vs Boyer–Moore)

### Additional Frequently Asked Problems
7. Product of Array Except Self  
8. Container With Most Water  
9. Move Zeroes (In-place)  
10. Trapping Rain Water (Two pointers / prefix max)

### What interviewer Evaluates
- Boundary handling
- O(1) space optimizations
- Ability to explain pointer movement logic

---

## DAY 2 – Hash Maps (interviewer Favorite)

### Concepts to Master
- Frequency counting
- Index mapping
- Hash + prefix sum pattern
- Time complexity degradation
- Equality vs hashing (conceptual)

### Core Problems
1. Two Sum (single-pass HashMap)
2. Group Anagrams
3. First Non-Repeating Character
4. Longest Consecutive Sequence
5. Subarray Sum Equals K (repeat until fluent)

### Additional Frequently Asked Problems
6. Contains Duplicate / Contains Duplicate II  
7. Longest Substring with At Most K Distinct Characters  
8. Intersection of Two Arrays (I & II)  
9. Find Pair with Given Difference  
10. Top K Frequent Elements (conceptual bridge to heaps)

### What interviewer Evaluates
- Deterministic behavior
- Clean HashMap usage
- Worst-case complexity awareness

---

## DAY 3 – Linked Lists (Pointer Confidence Day)

### Concepts to Master
- Pointer manipulation
- Dummy node pattern
- Fast & slow pointers
- Null safety
- Iterative vs recursive trade-offs

### Core Problems
1. Reverse Linked List (iterative mandatory)
2. Detect Cycle (Floyd’s Algorithm)
3. Find Middle of Linked List
4. Merge Two Sorted Lists
5. Remove Nth Node from End

### Additional Frequently Asked Problems
6. Intersection of Two Linked Lists  
7. Palindrome Linked List  
8. Swap Nodes in Pairs  
9. Odd Even Linked List  
10. Add Two Numbers (Linked List)

### What interviewer Evaluates
- Pointer correctness
- Confidence with references
- One-pass optimizations

---

## DAY 4 – Stack & Queue (Pattern Recognition Day)

### Concepts to Master
- Stack vs recursion
- Monotonic stack
- Deque usage
- Amortized O(1) analysis

### Core Problems
1. Valid Parentheses
2. Min Stack
3. Next Greater Element
4. Largest Rectangle in Histogram
5. Sliding Window Maximum

### Additional Frequently Asked Problems
6. Daily Temperatures  
7. Evaluate Reverse Polish Notation  
8. Simplify Unix Path  
9. Implement Queue Using Stacks  
10. First Non-Repeating Character in Stream

### What interviewer Evaluates
- Correct DS choice
- State tracking
- Clean iterative logic

---

## DAY 5 – Trees (BST-Centric, No Fluff)

### Concepts to Master
- Tree terminology
- DFS vs BFS
- Recursion stack depth
- Inorder traversal logic
- BST invariants

### Core Problems
1. Inorder / Preorder / Postorder Traversal
2. Validate BST (min/max boundary approach)
3. Height / Depth of Binary Tree
4. Lowest Common Ancestor (BST)
5. Kth Smallest Element in BST

### Additional Frequently Asked Problems
6. Symmetric Tree  
7. Invert Binary Tree  
8. Maximum Depth of Binary Tree  
9. Path Sum (Root-to-Leaf)  
10. Convert Sorted Array to BST

### What interviewer Evaluates
- Recursion clarity
- Stack overflow awareness
- Correct base cases

---

## DAY 6 – Heaps & Priority Queue (Practical Problems)

### Concepts to Master
- Min heap vs max heap
- Heap size control
- Heap vs sorting trade-offs
- Streaming data handling

### Core Problems
1. Kth Largest Element in an Array
2. Top K Frequent Elements
3. Merge K Sorted Lists
4. Median of Data Stream (two heaps – explanation focus)

### Additional Frequently Asked Problems
5. Meeting Rooms II  
6. Find K Closest Elements  
7. Sort Characters by Frequency  
8. Reorganize String  
9. Connect Ropes with Minimum Cost

### What interviewer Evaluates
- Greedy correctness
- Space vs time trade-offs
- Real-world applicability

---

## DAY 7 – Consolidation & Mock Thinking

### Step 1: Cold Re-Solve (No Notes)
Pick 5–6 problems:
- Subarray Sum Equals K  
- Reverse Linked List  
- Sliding Window Maximum  
- Validate BST  
- Kth Largest Element  
- Merge K Sorted Lists  

### Step 2: Verbal Explanation Practice
For each problem, explain:
- Why this data structure?
- Why not an alternative?
- Time & space complexity
- Edge cases
- How it behaves at scale

### Step 3: Pattern Revision (Only Patterns)
- Sliding window
- Two pointers
- Hash + prefix sum
- Fast & slow pointers
- Monotonic stack
- Inorder traversal
- Heap size control

---

## interviewer Absolute Filter Checklist

You **must** be fluent in:
- Two Sum  
- Subarray Sum Equals K  
- Maximum Subarray  
- Reverse Linked List  
- Detect Cycle  
- Valid Parentheses  
- Next Greater Element  
- Validate BST  
- Kth Largest Element  
- Merge K Sorted Lists  

---

## Final Note
This plan is **deliberately narrow and deep**.  
If you execute this well, you are preparing like a **senior candidate**, not a generalist.

Good luck — and trust the fundamentals.
